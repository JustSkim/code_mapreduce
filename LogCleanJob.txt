package com.xpjy.mr;        
        import java.net.URI;
        import java.text.ParseException;        
        importjava.text.SimpleDateFormat;        
        import java.util.Date;        
        import java.util.Locale;                        
        importorg.apache.hadoop.conf.Configuration;        
        importorg.apache.hadoop.conf.Configured;       
        import org.apache.hadoop.fs.FileSystem;       
        import org.apache.hadoop.fs.Path;        
        importorg.apache.hadoop.io.LongWritable;        
        importorg.apache.hadoop.io.NullWritable;        
        import org.apache.hadoop.io.Text;        
        importorg.apache.hadoop.mapreduce.Job;       
        importorg.apache.hadoop.mapreduce.Mapper;        
        import org.apache.hadoop.mapreduce.Reducer;        
        importorg.apache.hadoop.mapreduce.lib.input.FileInputFormat;        
        importorg.apache.hadoop.mapreduce.lib.output.FileOutputFormat;        
        importorg.apache.hadoop.util.Tool;       
        importorg.apache.hadoop.util.ToolRunner;                         
        public class LogCleanJob extends Configured implements Tool {                         
           //设置静态输入路径及输出路径，也可以通过 args 方式将 两个路径作为参数传入，该路径为 hdfs路径，非宿主机（linux）路径        
           //如使用args作为参数传入  INPUT_PATH ：args[0]   OUT_PAT:args[1]        
           static final String INPUT_PATH="hdfs://master:9000/data/demo1/input_path/access_2013_05_30.log";        
           static final String OUT_PATH="hdfs://master:9000/data/demo1/output_path";                         
            public static void main(String[] args) {        
               Configuration conf = newConfiguration();        
                try {        
                   int res = ToolRunner.run(conf, new LogCleanJob(), args);       
                   System.exit(res);        
                } catch (Exception e) {        
                   e.printStackTrace();        
                }        
            }                         
            @Override        
            public int run(String[] args) throws Exception {       
                final Job job = new Job(new Configuration(),        
                       LogCleanJob.class.getSimpleName());        
                // 设置为可以打包运行        
                job.setJarByClass(LogCleanJob.class);        
               FileInputFormat.setInputPaths(job, INPUT_PATH);        
                job.setMapperClass(MyMapper.class);        
                job.setMapOutputKeyClass(LongWritable.class);        
                job.setMapOutputValueClass(Text.class);        
                job.setReducerClass(MyReducer.class);        
                job.setOutputKeyClass(Text.class);        
                job.setOutputValueClass(NullWritable.class);        
               FileOutputFormat.setOutputPath(job, new Path(OUT_PATH));        
                // 清理已存在的输出文件        
               FileSystem fs = FileSystem.get(new URI(INPUT_PATH), getConf());        
                PathoutPath = new Path(OUT_PATH);        
                if (fs.exists(outPath)) {        
                   fs.delete(outPath, true);        
                }                               
                boolean success = job.waitForCompletion(true);        
                //如果清理数据成功输出 及 清理失败输出        
                if(success){        
                   System.out.println("Clean process success!");        
                }        
                else{        
                   System.out.println("Clean process failed!");        
                }        
                return 0;        
            }                                          
            static class MyMapper extends        
                   Mapper<LongWritable, Text, LongWritable, Text> {        
               LogParser logParser = new LogParser();        
                TextoutputValue = new Text();                         
                protected void map(       
                       LongWritable key,        
                       Text value,        
                       org.apache.hadoop.mapreduce.Mapper<LongWritable, Text, LongWritable, Text>.Context context)       
                       throwsjava.io.IOException, InterruptedException {        
                   final String[] parsed = logParser.parse(value.toString());                         
                   // step1.过滤掉静态资源访问请求        
                   if (parsed[2].startsWith("GET /static/")       
                           || parsed[2].startsWith("GET /uc_server")) {        
                       return;        
                   }        
                   // step2.过滤掉开头的指定字符串        
                   if (parsed[2].startsWith("GET /")) {        
                       parsed[2] = parsed[2].substring("GET /".length());        
                   } else if (parsed[2].startsWith("POST /")) {        
                       parsed[2] = parsed[2].substring("POST /".length());        
                   }        
                   // step3.过滤掉结尾的特定字符串        
                   if (parsed[2].endsWith(" HTTP/1.1")) {        
                       parsed[2] = parsed[2].substring(0, parsed[2].length()
                               - " HTTP/1.1".length());
                   }
                   // step4.只写入前三个记录类型项
                   outputValue.set(parsed[0] + "\t" + parsed[1] + "\t" + parsed[2]);        
                   context.write(key, outputValue);        
                }        
            }                         
            static class MyReducer extends        
                   Reducer<LongWritable, Text, Text, NullWritable> {        
                protected void reduce(        
                       LongWritable k2,        
                        java.lang.Iterable<Text>v2s,        
                       org.apache.hadoop.mapreduce.Reducer<LongWritable, Text, Text, NullWritable>.Context context)        
                       throwsjava.io.IOException, InterruptedException {        
                   for (Text v2 : v2s) {        
                        context.write(v2, NullWritable.get());       
                   }       
                };       
            }                    
            /*       
             * 日志解析类       
             */       
            static class LogParser {      
                public static final SimpleDateFormat FORMAT = new SimpleDateFormat(       
                       "d/MMM/yyyy:HH:mm:ss", Locale.ENGLISH);       
                public static final SimpleDateFormat dateformat1 = new SimpleDateFormat(       
                       "yyyyMMddHHmmss");                        
                public static void main(String[] args) throws ParseException {      
                   final String S1 = "27.19.74.143 - - [30/May/2013:17:38:20 +0800] \"GET /static/image/common/faq.gif HTTP/1.1\" 200 1127";       
                   LogParser parser = new LogParser();       
                   final String[] array = parser.parse(S1);       
                   System.out.println("样例数据：" + S1);       
                   System.out.format(       
                           "解析结果： ip=%s, time=%s, url=%s, status=%s, traffic=%s",       
                           array[0], array[1], array[2], array[3], array[4]);       
                }                        
                /**       
                * 解析英文时间字符串       
                *      
                * @param string       
                * @return       
                 * @throwsParseException       
                */       
                private Date parseDateFormat(String string) {       
                   Date parse = null;       
                   try {       
                       parse = FORMAT.parse(string);       
                   } catch (ParseExceptione) {       
                       e.printStackTrace();       
                   }       
                   return parse;       
                }                        
                /**       
                * 解析日志的行记录       
                *      
                * @param line       
                * @return 数组含有5个元素，分别是ip、时间、url、状态、流量       
                */       
                public String[] parse(String line) {       
                   String ip = parseIP(line);       
                   String time = parseTime(line);       
                   String url = parseURL(line);       
                   String status = parseStatus(line);       
                   String traffic = parseTraffic(line);                        
                   return new String[] { ip, time, url, status, traffic };       
                }              
                private String parseTraffic(Stringline) {       
                   final String trim = line.substring(line.lastIndexOf("\"") + 1)       
                           .trim();       
                   String traffic = trim.split(" ")[1];       
                   return traffic;      
                }                        
                private String parseStatus(String line) {       
                   final String trim = line.substring(line.lastIndexOf("\"") + 1)      
                           .trim();       
                   String status = trim.split(" ")[0];       
                   return status;       
                }                      
                private String parseURL(String line) {       
                   final int first = line.indexOf("\"");       
                   final int last = line.lastIndexOf("\"");       
                   String url = line.substring(first + 1, last);       
                   return url;       
                }                      
                private String parseTime(String line) {       
                   final int first = line.indexOf("[");       
                   final int last = line.indexOf("+0800]");       
                   String time = line.substring(first + 1, last).trim();       
                   Date date = parseDateFormat(time);       
                   return dateformat1.format(date);       
                }                        
                private String parseIP(String line) {       
                   String ip = line.split("- -")[0].trim();       
                   return ip;       
                }       
            }       
        }
